const express = require("express");
const Razorpay = require("razorpay");
const crypto=require('crypto')
const COURTSHEDULES=require('../models/courtTimingSchema')
const nodemailer=require('nodemailer')
 const WALLET=require('../models/walletSchema');
const courtShedules = require("../models/courtTimingSchema");


const generateorders= async (req, res) => {
    try {
        console.log(req.body.id);
        const slotData=await COURTSHEDULES.findOne({_id:req.body.id})
        if(slotData.bookedBy){
           return res.status(500).json({message:'already slot booked'})
        }
     
        const instance = new Razorpay({
            key_id: process.env.RAZORPAY_KEY_ID,
            key_secret: process.env.RAZORPAY_SECRET,
        });

        const options = {
            amount: slotData.cost*100, // amount in smallest currency unit it is 500 rs
            currency: "INR",
            receipt: slotData._id
        };

        const order = await instance.orders.create(options);

        if (!order) return res.status(500).send("Some error occured");

        res.json(order);
    } catch (error) {
        res.status(500).send(error);
    }
}

const paymentsuccess=async (req, res) => {
    try {
        // getting the details back from our font-end
        //console.log(req.body);
        const {
            orderCreationId,
            razorpayPaymentId,
            razorpayOrderId,
            razorpaySignature,
            receipt
        } = req.body;

        // Creating our own digest
        // The format should be like this:
        // digest = hmac_sha256(orderCreationId + "|" + razorpayPaymentId, secret);
        const shasum = crypto.createHmac("sha256", process.env.RAZORPAY_SECRET);

        shasum.update(`${orderCreationId}|${razorpayPaymentId}`);

        const digest = shasum.digest("hex");

        // comaparing our digest with the actual signature
        if (digest !== razorpaySignature)
            return res.status(400).json({ msg: "Transaction not legit!" });

        // THE PAYMENT IS LEGIT & VERIFIED
        // YOU CAN SAVE THE DETAILS IN YOUR DATABASE IF YOU WANT
        await COURTSHEDULES.updateOne({_id:receipt},{$set:{bookedBy:req.userId},$push :{paymentOrders:{userId:req.userId,razorpayPaymentId,timeStamp:new Date()}}})
initiateEmail(receipt, razorpayPaymentId)//reciept is the id of a particular slot =_id
        res.json({
            msg: "success",
            orderId: razorpayOrderId,
            paymentId: razorpayPaymentId,
        });
    } catch (error) {
        res.status(500).send(error);
    }
}
const initiateEmail= async (id, razorpayPaymentId)=>{
    const slotData = await COURTSHEDULES.findOne({_id:id}).populate('bookedBy').populate('courtId')
    console.log(slotData);
   
    const transporter = nodemailer.createTransport({
       service:"Gmail",
        auth: {
          // TODO: replace `user` and `pass` values from <https://forwardemail.net>
          user: 'shehanapareeth1@gmail.com',
          pass: 'yavq baof ttel cgsv'//generated by turning on 2step verification
        }
      });
      // object destructuring
const {date,slot,cost,bookedBy,courtId}=slotData    // send mail with defined transport object
    const info = await transporter.sendMail({
      from: 'shehanapareeth1@gmail.com', // sender address
      to: bookedBy.email, // list of receivers
      subject: "Booking confirmed at book my court", // Subject line
      text: "Thanks for booking with us!!", // plain text body
      html: `<b> Hello ${bookedBy.firstName + ' '+ bookedBy.lastName}
      ,br><p>your booking at ${courtId.name} on ${new Date(date)} at ${slot.name} has been confirmed with payment id :${ razorpayPaymentId}  </p>`, // html body
    });
    console.log("Message sent: %s", info.messageId);
}
const cancelBooking=(req,res)=>{
console.log(req.query.shedulesid);
console.log(req.userId);
COURTSHEDULES.updateOne({_id:req.query.shedulesid},{$unset:{bookedBy:''},$push : {canellation:{userId:req.userId,timeStamp:new Date()}}}).then((resp)=>{
    console.log(resp);
})
COURTSHEDULES.findOne({_id:req.query.shedulesid}).then((resp)=>{
    console.log(resp);

WALLET.findOne({userId:req.userId}).then((result)=>{
    if(result){
        let Amount=result.Amount+resp.cost
        console.log(Amount);
        WALLET.updateOne({ userId:req.userId},{$set:{Amount:Amount}}).then((re)=>{
            console.log(re);
            WALLET.findOne({ userId:req.userId}).then((resp)=>{
                console.log(resp);
                res.json({data:resp})
            })
        }) 
    }
    else{
        WALLET({
            userId:req.userId,
            timeStamp:new Date()
        }).save().then((response)=>{
            console.log(response);
            let Amount=response.Amount+resp.cost
            console.log(Amount);
            WALLET.updateOne({ userId:req.userId},{$set:{Amount:Amount}}).then((re)=>{
                console.log(re);
                WALLET.findOne({ userId:req.userId}).then((resp)=>{
                    console.log(resp);
                    res.json({data:resp})
                })
            })
        })
    }
}
)
  
})

}
const walletPayment=async(req,res)=>{
    console.log(req.query.id);
   const wallet=await WALLET.findOne({userId:req.userId},{Amount:1})
//console.log(wallet.Amount);
if(wallet){
    const shedulesDetails= await COURTSHEDULES.findOne({_id:req.query.id},{cost:1})
    //console.log(shedulesDetails.cost);
    if(wallet.Amount >= shedulesDetails.cost){
      console.log( wallet.Amount);  console.log(shedulesDetails.cost);
      let newAmount=wallet.Amount-shedulesDetails.cost
       console.log(newAmount);
        const updateWallet=await WALLET.updateOne({userId:req.userId},{$set:{Amount:newAmount}})
        const updateShedules= await COURTSHEDULES.updateOne({_id:req.query.id},{$set:{bookedBy:req.userId},$push:{paymentOrders:{userId:req.userId,walletId:wallet._id+new Date(),timeStamp:new Date()}}})
       res.json({message:'success'})
    
    
       initiateEmail(req.query.id, wallet._id+new Date())
    }
    else{
        res.json({message:'insufficient balance'})  
    } 
}
else{
    res.json({message:'insufficient balance'})  
}

}
const getwalletBalance= async (req,res)=>{
    const amount= await WALLET.findOne({userId:req.userId},{Amount:1})
    if(amount){
        console.log(amount.Amount);
        res.json({amount:amount.Amount})
    }
    else{
        res.json({amount:0})
    }

}

module.exports={getwalletBalance,walletPayment,generateorders,paymentsuccess,cancelBooking}

